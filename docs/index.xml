<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on SpringBoot Doc</title>
    <link>https://jaswine.com/docs/boot/docs/</link>
    <description>Recent content in Docs on SpringBoot Doc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://jaswine.com/docs/boot/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/base/log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/base/log/</guid>
      <description> SpringBoot日志配置 @SpringBoot版本:2.1.5.RELEASE
🔗官方文档
日志级别 日志级别顺序为:
trace &amp;lt; debug &amp;lt; info &amp;lt; warn &amp;lt;error  SpringBoot配置日志 调整级别(默认Info级别)
logging: level: org.springframework.bean: trace  输出日志文件
logging: file: springboot.log # 或者 logging: path: logs/xxx/  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/base/validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/base/validation/</guid>
      <description> SpringBoot参数校验 @SpringBoot版本:2.1.5.RELEASE
写代码要对参数/变量进行一下校验，这些校验的逻辑都是相同的，所以可以富用一套代码。
1.在SpringBoot项目中校验参数 引入依赖 在我们引入spring-boot-starter-web的时候已经自动帮我们引入了validation的组件
使用  1.在参数上加上约束
public class User{ @NotNull(message=&amp;quot;昵称不可为空&amp;quot;) private String nickName; }   2.加上校验  void XXX(@Vaild User user){ ... }   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/install/base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/install/base/</guid>
      <description> Redis安装 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/install/docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/install/docker/</guid>
      <description> 使用Docker安装Redis </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/install/yum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/install/yum/</guid>
      <description> 使用YUM安装Redis // 1.查询是否有可以安装的包 yum list redis // 2.没有的话安装仓库 yum install epel-release // 3.安装Redis yum install redis  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/mvc/config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/mvc/config/</guid>
      <description>Web MVC配置  Web MVC配置  跨域(CORS)配置 将Long型数据转换成String，解决前端接受Long精度丢失的问题   新建配置类实现🔗WebMvcConfigurer接口
跨域(CORS)配置  跨域的原理和解决方案:
 🔗跨域(CORS)的解决办法和原理   @Bean public CorsFilter corsFilter() { CorsConfiguration configuration = new CorsConfiguration(); configuration.addAllowedHeader(&amp;quot;*&amp;quot;); configuration.addAllowedMethod(&amp;quot;*&amp;quot;); configuration.addAllowedOrigin(&amp;quot;*&amp;quot;); configuration.setAllowCredentials(true); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&amp;quot;/**&amp;quot;, configuration); log.info(&amp;quot;配置CORS&amp;quot;); return new CorsFilter(source); }  将Long型数据转换成String，解决前端接受Long精度丢失的问题 在使用微服务的过程中，数据库中Id是使用雪花算法生成的id，是long的数据，返给前端js接受存在精度丢失的问题。
@Override public void configureMessageConverters(List&amp;lt;HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converters) { log.info(&amp;quot;配置JSON转换器&amp;quot;); MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); // Object和Json转换对象 ObjectMapper mapper = new ObjectMapper(); // ObjectMapper的Module SimpleModule module = new SimpleModule(); module.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/mvc/exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/mvc/exception/</guid>
      <description> 全局异常处理 项目中很多时候抛出异常，很多异常都是相同的，如果每一个异常都需要自己去处理的话代码就显得臃肿和重复，SpringBoot提供统一处理异常的方法。
统一异常处理类  新建异常处理类 加上@ControllerAdvice注解 编写异常处理方法(加上@ExceptionHandler注解)  这样就可以统一来处理异常了
Example:
/** * 异常拦截 * * @author jaswine */ @ControllerAdvice public class ExceptionAdviceRest { @ResponseBody @ExceptionHandler(value = DuplicateKeyException.class) public DTO doubleKeyException(Exception e){ return new SimpleRtnDTO(CustomRtnEnum.ERROR.getStatus(),&amp;quot;数据库中已存在&amp;quot;); } @ResponseBody @ExceptionHandler(value = Exception.class) public DTO errorHandler(Exception e){ e.printStackTrace(); return new SimpleRtnDTO(CustomRtnEnum.ERROR.getStatus(),e.getMessage()); } }  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/mvc/filterintercept/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/mvc/filterintercept/</guid>
      <description> Filter和Intercept </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/mvc/restful/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/mvc/restful/</guid>
      <description> RESTful风格API RESTful是一种规范和风格，不是一种技术，如果你的API满足这种风格那就是RESTful风格的API
关于RESTful的文章可以看这里:
 🔗REST - Roy Thomas博士论文  RESTful成熟度  层级1: 使用HTTP作为网络传输协议 层级2: URL表示资源 层级3: 使用HTTP方法表示行为方式 层级4: 超媒体控制  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/quartz/quartz/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/quartz/quartz/</guid>
      <description> SpringBoot整合Quartz  SpringBoot@Version:2.1.5.RELEASE Quartz@Version:2.3.1  Quartz是一个作业调度框架，有以下特性:
 支持复杂的时间调度 作业可以持久化 支持集群  引入依赖包 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-quartz&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  配置 我们使用Quartz是将任务持久化到数据库中的，Quartz读取数据库中的信息然后定时执行任务。
SpringBoot配置
################## # Quartz配置 # ################## spring: quartz: job-store-type: jdbc jdbc: initialize-schema: always schema: classpath:dbscript/quartz_mysql_innodb.sql properties: org: quaretz: scheduler: instanceName: REPORT_TASK instanceId: AUTO jobStore: class: org.quartz.impl.jdbcjobstore.JobStoreTX driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate tablePrefix: QRTZ_ isClustered: true clusterCheckinInterval: 10000 useProperties: false threadPool: class: org.quartz.simpl.SimpleThreadPool threadCount: 10 threadPriority: 5 threadsInheritContextClassLoaderOfInitializingThread: true  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/security/authenticationdecision/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/security/authenticationdecision/</guid>
      <description> 自定义授权方式 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/security/base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/security/base/</guid>
      <description> SpringBoot整合Security @SpringBoot版本 : 2.0.4.RELEASE
应用环境 在我们开发Web应用程序的过程中，我们需要对我们的资源(URI)进行保护。我们常用的安全框架有Apache Shiro和Spring Security。Shiro我没有使用过，但是和Spring Security相比比较简单但是粒度也比较从粗。
在SpringBoot ，Spring Cloud大行其道的当下，Java开发已经等同于Spring开发了，Spring Security属于Spring的大家族一员，和自己的大哥整合的比较好，并且人家自己做的也不错啊。
Features 网上的教程都是很零散的Demo级别的教程，都是点级别的知识点，对于知道Spring Security详细细节的开发还好 ，如果初级入门 Spring Security的话就非常不友好，所以我想写这个Blog的时候遵循Arch-First(架构优先)的原则，先开启上帝视角来看Spring Security的运行原理，然后再深入进去修改每一个细节。
这个Blog是生产环境下使用的，动态的权限，动态的角色，不会像很多Demo中写的那样使用@PreAuthorize(&amp;quot;hasRole(&#39;ADMIN&#39;)&amp;quot;)这样子。
 基于数据库的动态权限认证 RBAC权限模型 Json返回，前后端分离 SpringBoot2.0+  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/security/oauth2/base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/security/oauth2/base/</guid>
      <description> OAuth2协议概念 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/security/oauth2/explain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/security/oauth2/explain/</guid>
      <description> OAUTH2配置&amp;amp;重要类说明 @springCloud版本:Finchley.SR2
配置文件说明 重要类  TokenStore
Token持久化方式【TokenStore-DOC】
 AccessTokenConverter
对象持久化转化器【AccessTokenConverter- DOC】
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/security/oauth2/table/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/security/oauth2/table/</guid>
      <description> OAuth2中的默认数据表 使用Spring Security Oauth2来实现OAuth2标准的授权中有6张默认的表,知道这些表是什么意思很好
 oauth_access_token oauth_approvals oauth_client_details oauth_client_token oauth_code oauth_refresh_token  oauth_access_token
   字段 作用 备注     create_time 创建时间,插入的时候自动生成 扩展字段   token_id access_token进行MD5加密后存储    token     authenticatication_id 由username,client_id,scope进行MD5加密生成    user_name 登录的时候用户名    client_id k客户端id    authentication Oauth2Authentication对象序列化后的数据    refresh_token 将refresh_token的值通过MD5加密后存储     </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/security/overlooking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/security/overlooking/</guid>
      <description>俯瞰Spring Security @SpringBoot 版本：2.0.4.RELEASE
@源码分析： Spring Security源代码分析
Spring Security可以对Java Web程序提供安全授权和认证，同时还能整合Oauth2来完成SSO(单点登陆)功能，SSO是微服务框架中的基础功能，大型分布式应用网站都是一个个单独的应用，每个应用的资源都要受到保护，但是每一个系统开发一套权限的功能不能满足要求。在微服务中权限的控制本质上已经是一个单独的服务对外提供服务。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/security/redirectjson/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/security/redirectjson/</guid>
      <description> 前后端分离实现RESTful登录 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/security/start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/security/start/</guid>
      <description> 工程起步 @SpringBoot版本： 2.0.4.RELEASE
默认你已经建好了SpringBoot工程。我建立的工程结构如下
// TODO 工程架构图
1.引入Security依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  2.配置WebSecurity文件 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/security/success2failedhandler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/security/success2failedhandler/</guid>
      <description> 自定义成功/失败登录逻辑 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/security/userdetailsservice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/security/userdetailsservice/</guid>
      <description> 重写UserDetailsService返回自定义的UserDetail public static LocalDateTime add(LocalDateTime localDateTime, TimeEnum timeEnum, long num) { switch (timeEnum) { case SECOND: return localDateTime.plus(num, ChronoUnit.SECONDS); case MINUTE: return localDateTime.plus(num, ChronoUnit.MINUTES); case DAY: return localDateTime.plus(num, ChronoUnit.DAYS); case HOUR: return localDateTime.plus(num, ChronoUnit.HOURS); case WEEK: return localDateTime.plus(num, ChronoUnit.WEEKS); case MONTH: return localDateTime.plus(num, ChronoUnit.MONTHS); case YEAR: return localDateTime.plus(num, ChronoUnit.YEARS); default: throw new TimeUtilException(); } }  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jaswine.com/docs/boot/docs/tools/devtools/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jaswine.com/docs/boot/docs/tools/devtools/</guid>
      <description> 使用Devtools来方便项目开发 </description>
    </item>
    
  </channel>
</rss>